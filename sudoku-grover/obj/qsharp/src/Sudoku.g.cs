//------------------------------------------------------------------------------
// <auto-generated>                                                             
//     This code was generated by a tool.                                       
//     Changes to this file may cause incorrect behavior and will be lost if    
//     the code is regenerated.                                                 
// </auto-generated>                                                            
//------------------------------------------------------------------------------
#pragma warning disable 436
#pragma warning disable 162
#pragma warning disable 1591
using System;
using Microsoft.Quantum.Core;
using Microsoft.Quantum.Intrinsic;
using Microsoft.Quantum.Simulation.Core;

[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Microsoft.Quantum.Samples.SudokuGrover\",\"Name\":\"SolvePuzzle\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs\",\"Position\":{\"Item1\":105,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":22}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numVertices\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":20}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"size\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":28},\"Item2\":{\"Line\":2,\"Column\":32}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"emptySquareEdges\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":25}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"startingNumberConstraints\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":34}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]}]]},\"ReturnType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Bool\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Int\"}]}]]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Solve a Sudoku puzzle using Grover's algorithm.\",\"\",\" # Description\",\" Sudoku is a graph coloring problem where graph edges must connect nodes\",\" of different colors.\",\" In our case, graph nodes are puzzle squares and colors are the Sudoku numbers.\",\" Graph edges are the constraints preventing squares from having the same values.\",\" To reduce the number of qubits needed, we only use qubits for empty squares.\",\" We define the puzzle using 2 data structures:\",\"\",\"   - A list of edges connecting empty squares\",\"   - A list of constraints on empty squares to the initial numbers\",\"     in the puzzle (starting numbers)\",\" The code works for both 9x9 Sudoku puzzles, and 4x4 Sudoku puzzles.\",\" This description will use a 4x4 puzzle to make it easier to understand.\",\" The 4x4 puzzle is solved with number 0 to 3 instead of 1 to 4.\",\" This is because we can encode 0-3 with 2 qubits.\",\" However, the same rules apply:\",\"    - The numbers 0 to 3 may only appear once per row, column and 2x2 sub squares.\",\" As an example              has solution\",\" _________________          _________________\",\" |   | 1 |   | 3 |          | 0 | 1 | 2 | 3 |\",\" -----------------          -----------------\",\" | 2 |   |   | 1 |          | 2 | 3 | 0 | 1 |\",\" -----------------          -----------------\",\" |   |   | 3 | 0 |          | 1 | 2 | 3 | 0 |\",\" -----------------          -----------------\",\" | 3 |   | 1 |   |          | 3 | 0 | 1 | 2 |\",\" -----------------          -----------------\",\"\",\" In the above example, the edges/constraints for the top row are:\",\"   _________\",\"  | ______   \\\\                   _____\",\"  || __   \\\\   \\\\                  | __  \\\\                        __\",\" _|||__\\\\___\\\\_ _\\\\__         ______||__\\\\___\\\\__          _________|___\\\\__\",\" |   | 1 |   | 3 |         |   | 1 |   | 3 |         |   | 1 |   | 3 |\",\" -----------------         -----------------         -----------------\",\"\",\" For the row above, the empty squares have indexes\",\" _________________\",\" | 0 |   | 1 |   |\",\" -----------------\",\" For this row the list of emptySquareEdges has only 1 entry:\",\" emptySquareEdges = (0,1)\",\" i.e. empty square 0 can't have the same number as empty square 1.\",\" The constraints on these empty squares to the starting numbers are:\",\" startingNumberConstraints = (0,1)  (0,3)  (1,1)  (1,3)\",\" This is a list of (empty square #, number it can't be).\",\" i.e. empty square 0 can't have value 1 or 3,\",\" and empty square #1 can't have values 1 or 3.\",\"\",\" # Input\",\" ## numVertices\",\" number of blank squares.\",\" ## size\",\" The size of the puzzle. 4 for 4x4 grid, 9 for 9x9 grid.\",\" ## emptySquareEdges\",\" The traditional edges passed to the graph coloring algorithm which,\",\" in our case, are empty puzzle squares.\",\" These edges define any \\\"same row\\\", \\\"same column\\\", \\\"same sub-grid\\\"\",\" relationships between empty cells.\",\" Look at the README.md sample output to see examples of what this is\",\" for different sample puzzles.\",\" ## startingNumberConstraints\",\" The constraints on the empty squares due to numbers already in the\",\" puzzle when we start.\",\" Look at the README.md sample output to see examples of what this is\",\" for different sample puzzles.\",\"\",\" # Output\",\" A tuple with Result and the array of numbers for each empty square.\",\" Look at the README.md sample output to see examples of what this is\",\" for different sample puzzles.\",\"\",\" # Remarks\",\" The inputs and outputs for the following 4x4 puzzle are:\",\"    -----------------\",\"    |   | 1 | 2 | 3 |         <--- empty square #0\",\"    -----------------\",\"    | 2 |   | 0 | 1 |         <--- empty square #1\",\"    -----------------\",\"    | 1 | 2 | 3 | 0 |\",\"    -----------------\",\"    | 3 |   | 1 | 2 |         <--- empty square #2\",\"    -----------------\",\"    emptySquareEdges = [(1, 0),(2, 1)]\",\"         empty square #0 can not have the same color/number as empty call #1.\",\"         empty square #1 and #2 can not have the same color/number (same column).\",\"    startingNumberConstraints = [(0, 2),(0, 1),(0, 3),(1, 1),(1, 2),(1, 0),(2, 1),(2, 2),(2, 3)]\",\"         empty square #0 can not have values 2,1,3 because same row/column/2x2grid.\",\"         empty square #1 can not have values 1,2,0 because same row/column/2x2grid.\",\"    Results = [0,3,0] i.e. Empty Square #0 = 0, Empty Square #1 = 3, Empty Square #2 = 0.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Microsoft.Quantum.Samples.SudokuGrover\",\"Name\":\"SolvePuzzle\"},\"Attributes\":[],\"SourceFile\":\"/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs\",\"Position\":{\"Item1\":105,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":22}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Function\"},\"QualifiedName\":{\"Namespace\":\"Microsoft.Quantum.Samples.SudokuGrover\",\"Name\":\"NIterations\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs\",\"Position\":{\"Item1\":156,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":21}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"nQubits\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":22},\"Item2\":{\"Line\":1,\"Column\":29}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"Int\"},\"ReturnType\":{\"Case\":\"Int\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Estimate the number of iterations required for solution.\",\"\",\" # Input\",\" ## nQubits\",\" The number of qubits being used.\",\"\",\" # Remarks\",\" This is correct for an amplitude amplification problem with a single\",\" correct solution, but would need to be adapted when there are multiple\",\" solutions\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Microsoft.Quantum.Samples.SudokuGrover\",\"Name\":\"NIterations\"},\"Attributes\":[],\"SourceFile\":\"/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs\",\"Position\":{\"Item1\":156,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":21}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Function\"},\"QualifiedName\":{\"Namespace\":\"Microsoft.Quantum.Samples.SudokuGrover\",\"Name\":\"IsSudokuSolutionValid\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs\",\"Position\":{\"Item1\":187,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":31}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"size\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":13}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"edges\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":14}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"startingNumberConstraints\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":34}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"colors\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Int\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":5,\"Column\":9},\"Item2\":{\"Line\":5,\"Column\":15}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Int\"}]}]]},\"ReturnType\":{\"Case\":\"Bool\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Check if the colors/numbers found for each empty square are in the correct\",\" range (e.g. <9 for a 9x9 puzzle) and satisfy all edge/starting number constraints.\",\"\",\" # Input\",\" ## size\",\" The size of the puzzle. 4 for 4x4 grid, 9 for 9x9 grid.\",\" ## edges\",\" The traditional edges passed to the graph coloring algorithm which,\",\" in our case, are empty puzzle squares.\",\" These edges define any \\\"same row\\\", \\\"same column\\\", \\\"same sub-grid\\\"\",\" relationships between empty cells.\",\" Look at the README.md sample output to see examples of what this is\",\" for different sample puzzles.\",\" ## startingNumberConstraints\",\" The constraints on the empty squares due to numbers already in the\",\" puzzle when we start. Look at the README.md sample output to see\",\" examples of what this is for different sample puzzles.\",\" ## colors\",\" An Int array of numbers for each empty square i.e. the puzzle solution.\",\"\",\" # Output\",\" A boolean value of true if the colors found satisfy all the solution requirements.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Microsoft.Quantum.Samples.SudokuGrover\",\"Name\":\"IsSudokuSolutionValid\"},\"Attributes\":[],\"SourceFile\":\"/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs\",\"Position\":{\"Item1\":187,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":31}},\"Documentation\":[]}")]
#line hidden
namespace Microsoft.Quantum.Samples.SudokuGrover
{
    [SourceLocation("/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs", OperationFunctor.Body, 106, 157)]
    public partial class SolvePuzzle : Operation<(Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>), (Boolean,IQArray<Int64>)>, ICallable
    {
        public SolvePuzzle(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>)>, IApplyData
        {
            public In((Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        public class Out : QTuple<(Boolean,IQArray<Int64>)>, IApplyData
        {
            public Out((Boolean,IQArray<Int64>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "SolvePuzzle";
        String ICallable.FullName => "Microsoft.Quantum.Samples.SudokuGrover.SolvePuzzle";
        protected IUnitary<(Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Qubit>,Qubit)> Microsoft__Quantum__Samples__ColoringGroverWithConstraints__ApplyVertexColoringOracle
        {
            get;
            set;
        }

        protected IUnitary<(Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Qubit>,Qubit)> Microsoft__Quantum__Samples__ColoringGroverWithConstraints__ApplyVertexColoringOracle4Bit9Color
        {
            get;
            set;
        }

        protected ICallable<Int64, Int64> NIterations__
        {
            get;
            set;
        }

        protected ICallable<String, QVoid> Message__
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Int64,IAdjointable), IQArray<Int64>> Microsoft__Quantum__Samples__ColoringGroverWithConstraints__FindColorsWithGrover
        {
            get;
            set;
        }

        protected ICallable<(Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Int64>), Boolean> IsSudokuSolutionValid__
        {
            get;
            set;
        }

        public override Func<(Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>), (Boolean,IQArray<Int64>)> __Body__ => (__in__) =>
        {
            var (numVertices,size,emptySquareEdges,startingNumberConstraints) = __in__;
#line 113 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            var bitsPerColor = ((size == 9L) ? 4L : 2L);
#line 114 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            var oracle = Microsoft__Quantum__Samples__ColoringGroverWithConstraints__ApplyVertexColoringOracle.Partial(new Func<(IQArray<Qubit>,Qubit), (Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Qubit>,Qubit)>((__arg1__) => (numVertices, bitsPerColor, emptySquareEdges, startingNumberConstraints, __arg1__.Item1, __arg1__.Item2)));
#line 115 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            if ((size == 9L))
            {
#line 123 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                oracle = Microsoft__Quantum__Samples__ColoringGroverWithConstraints__ApplyVertexColoringOracle4Bit9Color.Partial(new Func<(IQArray<Qubit>,Qubit), (Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Qubit>,Qubit)>((__arg2__) => (numVertices, emptySquareEdges, startingNumberConstraints, __arg2__.Item1, __arg2__.Item2)));
            }
            else if ((size != 4L))
            {
#line 125 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                throw new ExecutionFailException(String.Format("Cannot set size {0}: only a grid size of 4x4 or 9x9 is supported", size));
            }

#line 127 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            var numIterations = NIterations__.Apply((bitsPerColor * numVertices));
#line 128 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            Message__.Apply(String.Format("Running Quantum test with #Vertex = {0}", numVertices));
#line 129 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            Message__.Apply(String.Format("   Bits Per Color = {0}", bitsPerColor));
#line 130 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            Message__.Apply(String.Format("   emptySquareEdges = {0}", emptySquareEdges));
#line 131 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            Message__.Apply(String.Format("   startingNumberConstraints = {0}", startingNumberConstraints));
#line 132 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            Message__.Apply(String.Format("   Estimated #iterations needed = {0}", numIterations));
#line 133 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            Message__.Apply(String.Format("   Size of Sudoku grid = {0}x{1}", size, size));
#line 134 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            var coloring = (IQArray<Int64>)Microsoft__Quantum__Samples__ColoringGroverWithConstraints__FindColorsWithGrover.Apply((numVertices, bitsPerColor, numIterations, oracle));
#line 136 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            Message__.Apply(String.Format("Got Sudoku solution: {0}", coloring));
#line 137 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            if (IsSudokuSolutionValid__.Apply((size, emptySquareEdges, startingNumberConstraints, coloring)))
            {
#line 138 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                Message__.Apply(String.Format("Got valid Sudoku solution: {0}", coloring));
#line 139 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                return (true, coloring);
            }
            else
            {
#line 141 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                Message__.Apply(String.Format("Got invalid Sudoku solution: {0}", coloring));
#line 142 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                return (false, coloring);
            }
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Samples__ColoringGroverWithConstraints__ApplyVertexColoringOracle = this.__Factory__.Get<IUnitary<(Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Qubit>,Qubit)>>(typeof(global::Microsoft.Quantum.Samples.ColoringGroverWithConstraints.ApplyVertexColoringOracle));
            this.Microsoft__Quantum__Samples__ColoringGroverWithConstraints__ApplyVertexColoringOracle4Bit9Color = this.__Factory__.Get<IUnitary<(Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Qubit>,Qubit)>>(typeof(global::Microsoft.Quantum.Samples.ColoringGroverWithConstraints.ApplyVertexColoringOracle4Bit9Color));
            this.NIterations__ = this.__Factory__.Get<ICallable<Int64, Int64>>(typeof(NIterations));
            this.Message__ = this.__Factory__.Get<ICallable<String, QVoid>>(typeof(global::Microsoft.Quantum.Intrinsic.Message));
            this.Microsoft__Quantum__Samples__ColoringGroverWithConstraints__FindColorsWithGrover = this.__Factory__.Get<ICallable<(Int64,Int64,Int64,IAdjointable), IQArray<Int64>>>(typeof(global::Microsoft.Quantum.Samples.ColoringGroverWithConstraints.FindColorsWithGrover));
            this.IsSudokuSolutionValid__ = this.__Factory__.Get<ICallable<(Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Int64>), Boolean>>(typeof(IsSudokuSolutionValid));
        }

        public override IApplyData __DataIn__((Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>) data) => new In(data);
        public override IApplyData __DataOut__((Boolean,IQArray<Int64>) data) => new Out(data);
        public static System.Threading.Tasks.Task<(Boolean,IQArray<Int64>)> Run(IOperationFactory __m__, Int64 numVertices, Int64 size, IQArray<(Int64,Int64)> emptySquareEdges, IQArray<(Int64,Int64)> startingNumberConstraints)
        {
            return __m__.Run<SolvePuzzle, (Int64,Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>), (Boolean,IQArray<Int64>)>((numVertices, size, emptySquareEdges, startingNumberConstraints));
        }
    }

    [SourceLocation("/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs", OperationFunctor.Body, 157, 188)]
    public partial class NIterations : Function<Int64, Int64>, ICallable
    {
        public NIterations(IOperationFactory m) : base(m)
        {
        }

        String ICallable.Name => "NIterations";
        String ICallable.FullName => "Microsoft.Quantum.Samples.SudokuGrover.NIterations";
        protected ICallable<Double, Double> Microsoft__Quantum__Math__ArcSin
        {
            get;
            set;
        }

        protected ICallable<Double, Double> Microsoft__Quantum__Math__Sqrt
        {
            get;
            set;
        }

        protected ICallable<Int64, Double> Microsoft__Quantum__Convert__IntAsDouble
        {
            get;
            set;
        }

        protected ICallable<Double, Int64> Microsoft__Quantum__Math__Round
        {
            get;
            set;
        }

        protected ICallable<QVoid, Double> Microsoft__Quantum__Math__PI
        {
            get;
            set;
        }

        public override Func<Int64, Int64> __Body__ => (__in__) =>
        {
            var nQubits = __in__;
#line 158 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            var nItems = (1L << (int)nQubits);
#line 160 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            var angle = Microsoft__Quantum__Math__ArcSin.Apply((1D / Microsoft__Quantum__Math__Sqrt.Apply(Microsoft__Quantum__Convert__IntAsDouble.Apply(nItems))));
#line 161 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            var nIterations = Microsoft__Quantum__Math__Round.Apply((((0.25D * Microsoft__Quantum__Math__PI.Apply(QVoid.Instance)) / angle) - 0.5D));
#line 162 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            return nIterations;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Math__ArcSin = this.__Factory__.Get<ICallable<Double, Double>>(typeof(global::Microsoft.Quantum.Math.ArcSin));
            this.Microsoft__Quantum__Math__Sqrt = this.__Factory__.Get<ICallable<Double, Double>>(typeof(global::Microsoft.Quantum.Math.Sqrt));
            this.Microsoft__Quantum__Convert__IntAsDouble = this.__Factory__.Get<ICallable<Int64, Double>>(typeof(global::Microsoft.Quantum.Convert.IntAsDouble));
            this.Microsoft__Quantum__Math__Round = this.__Factory__.Get<ICallable<Double, Int64>>(typeof(global::Microsoft.Quantum.Math.Round));
            this.Microsoft__Quantum__Math__PI = this.__Factory__.Get<ICallable<QVoid, Double>>(typeof(global::Microsoft.Quantum.Math.PI));
        }

        public override IApplyData __DataIn__(Int64 data) => new QTuple<Int64>(data);
        public override IApplyData __DataOut__(Int64 data) => new QTuple<Int64>(data);
        public static System.Threading.Tasks.Task<Int64> Run(IOperationFactory __m__, Int64 nQubits)
        {
            return __m__.Run<NIterations, Int64, Int64>(nQubits);
        }
    }

    [SourceLocation("/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs", OperationFunctor.Body, 188, -1)]
    public partial class IsSudokuSolutionValid : Function<(Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Int64>), Boolean>, ICallable
    {
        public IsSudokuSolutionValid(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Int64>)>, IApplyData
        {
            public In((Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Int64>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "IsSudokuSolutionValid";
        String ICallable.FullName => "Microsoft.Quantum.Samples.SudokuGrover.IsSudokuSolutionValid";
        protected ICallable Microsoft__Quantum__Arrays__Any
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Boolean> Microsoft__Quantum__Logical__GreaterThanOrEqualI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Boolean> Microsoft__Quantum__Logical__EqualI
        {
            get;
            set;
        }

        public override Func<(Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Int64>), Boolean> __Body__ => (__in__) =>
        {
            var (size,edges,startingNumberConstraints,colors) = __in__;
#line 195 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            if (Microsoft__Quantum__Arrays__Any.Apply<Boolean>((Microsoft__Quantum__Logical__GreaterThanOrEqualI.Partial(new Func<Int64, (Int64,Int64)>((__arg1__) => (__arg1__, size))), colors)))
            {
#line 195 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                return false;
            }

#line 196 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            if (Microsoft__Quantum__Arrays__Any.Apply<Boolean>((Microsoft__Quantum__Logical__EqualI, edges)))
            {
#line 196 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                return false;
            }

#line 197 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            foreach (var (index,startingNumber) in startingNumberConstraints)
#line hidden
            {
#line 198 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                if ((colors[index] == startingNumber))
                {
#line 199 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
                    return false;
                }
            }

#line 202 "/Users/ashwin/Desktop/idk/sudoku-grover/Sudoku.qs"
            return true;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Arrays__Any = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Arrays.Any<>));
            this.Microsoft__Quantum__Logical__GreaterThanOrEqualI = this.__Factory__.Get<ICallable<(Int64,Int64), Boolean>>(typeof(global::Microsoft.Quantum.Logical.GreaterThanOrEqualI));
            this.Microsoft__Quantum__Logical__EqualI = this.__Factory__.Get<ICallable<(Int64,Int64), Boolean>>(typeof(global::Microsoft.Quantum.Logical.EqualI));
        }

        public override IApplyData __DataIn__((Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Int64>) data) => new In(data);
        public override IApplyData __DataOut__(Boolean data) => new QTuple<Boolean>(data);
        public static System.Threading.Tasks.Task<Boolean> Run(IOperationFactory __m__, Int64 size, IQArray<(Int64,Int64)> edges, IQArray<(Int64,Int64)> startingNumberConstraints, IQArray<Int64> colors)
        {
            return __m__.Run<IsSudokuSolutionValid, (Int64,IQArray<(Int64,Int64)>,IQArray<(Int64,Int64)>,IQArray<Int64>), Boolean>((size, edges, startingNumberConstraints, colors));
        }
    }
}